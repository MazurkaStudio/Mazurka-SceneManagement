using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace TheMazurkaStudio.SceneManagement
{
    public class SceneLoadingManager : MonoBehaviour
    {
        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
        public static void InitializeSceneManager()
        {
            var instance = new GameObject("SceneLoadingManager [AutoGenerated]").AddComponent<SceneLoadingManager>();
            instance.activeScenes = new Dictionary<string, Scene>();
            instance.commandQueue = new Queue<SceneCommand>();
            instance.loadedScenes = new HashSet<string>();

            //Add initial scene (first scene, and any scene already open in editor)
            for (int i = 0; i < SceneManager.sceneCount; i++)
            {
                instance.loadedScenes.Add(SceneManager.GetSceneAt(i).name);
            }
            
            DontDestroyOnLoad(instance);
            SceneManager.sceneLoaded += instance.OnSceneLoaded;
            SceneManager.sceneUnloaded += instance.OnSceneUnloaded;
            if (Instance != null)
                throw new Exception(
                    "You can't create more than one instance of SceneLoadingManager, the singleton is auto generated you don't need to instantiate it yourself in the game");
            
            Instance = instance;
        }
        
        public static SceneLoadingManager Instance { get; private set; }

        private void Awake()
        {
            if (Instance != null && Instance != this)
            {
                Debug.LogError("You can't create more than one instance of SceneLoadingManager, the singleton is auto generated you don't need to instantiate it yourself in the game");
                Destroy(gameObject);
            }
        }

        private Dictionary<string, Scene> activeScenes;
        private HashSet<string> loadedScenes;

        public void LoadScene(string sceneName, LoadSceneMode loadSceneMode, bool allowSceneActivation, Action onCompleted)
        {
            new LoadSceneParameters()
            {
                scenesToLoad = new []{sceneName},
                loadSceneMode = loadSceneMode,
                allowSceneActivation = allowSceneActivation,
            }.Execute(onCompleted);
        }
        
        public void UnloadScene(string sceneName, UnloadSceneOptions unloadSceneOptions, bool allowSceneActivation, Action onCompleted)
        {
            new UnloadSceneParameters()
            {
                scenesToUnload = new []{sceneName},
                unloadSceneMode = unloadSceneOptions,
            }.Execute(onCompleted);
        }
        
        public void LoadScene(LoadSceneParameters parameters, Action onCompleted)
        {
            //One scene case
            if (parameters.HaveOnlyOneSceneToLoad)
            {
                var sceneName = Path.GetFileNameWithoutExtension(parameters.scenesToLoad[0]);

                if (string.IsNullOrEmpty(sceneName))
                {
                    Debug.LogWarning("You are trying to load an empty or null reference scene this is not allowed");
                    onCompleted?.Invoke();
                    return;
                }
                 
                if (loadedScenes.Contains(sceneName))
                {
                    Debug.LogWarning($"You are trying to load scene {sceneName} that is already loaded or in loading, this is not allowed");
                    onCompleted?.Invoke();
                    return;
                }

                parameters.scenesToLoad = new string[1] { sceneName };

                loadedScenes.Add(sceneName);
                PostCommand(new LoadSceneCommand(parameters, onCompleted));
                return;
            }

            var scenesToLoad = new List<string>();
            
            //Check all scene to avoid loading an already loaded scene
            foreach (var sceneName in parameters.scenesToLoad)
            {
                var trueName = Path.GetFileNameWithoutExtension(sceneName);
                
                if (string.IsNullOrEmpty(trueName))
                {
                    Debug.LogWarning("You are trying to load an empty or null reference scene this is not allowed");
                    continue;
                }
                 
                if (loadedScenes.Contains(trueName))
                {
                    Debug.LogWarning($"You are trying to load scene {trueName} that is already loaded or in loading, this is not allowed");
                    continue;
                }

                loadedScenes.Add(trueName);
                scenesToLoad.Add(trueName);
            }

            //Finally there is no scene to load
            if (scenesToLoad.Count < 1)
            {
                onCompleted?.Invoke();
                return;
            }

            var newParameters = new LoadSceneParameters()
            {
                scenesToLoad = scenesToLoad.ToArray(),
                loadSceneMode = LoadSceneMode.Additive,
                allowSceneActivation = parameters.allowSceneActivation,
            };

            PostCommand(new LoadSceneCommand(newParameters, onCompleted));
        }

        public void UnloadScene(UnloadSceneParameters parameters, Action onCompleted)
        {
            //One scene case
            if (parameters.HaveOnlyOneSceneToLoad)
            {
                var sceneName = Path.GetFileNameWithoutExtension(parameters.scenesToUnload[0]);

                if (string.IsNullOrEmpty(sceneName))
                {
                    Debug.LogWarning("You are trying to unload an empty or null reference scene this is not allowed");
                    onCompleted?.Invoke();
                    return;
                }
                 
                if (!loadedScenes.Contains(sceneName))
                {
                    Debug.LogWarning($"You are trying to unload scene {sceneName} that is not loaded or in loading, this is not allowed");
                    onCompleted?.Invoke();
                    return;
                }

                loadedScenes.Remove(sceneName);
                PostCommand(new UnLoadSceneCommand(parameters, onCompleted));
                return;
            }

            var scenesToUnload = new List<string>();
            
            //Check all scene to avoid loading an already loaded scene
            foreach (var sceneName in parameters.scenesToUnload)
            {
                var trueName = Path.GetFileNameWithoutExtension(sceneName);
                
                if (string.IsNullOrEmpty(sceneName))
                {
                    Debug.LogWarning("You are trying to unload an empty or null reference scene this is not allowed");
                    continue;
                }
                 
                if (!loadedScenes.Contains(sceneName))
                {
                    Debug.LogWarning($"You are trying to unload scene {trueName} that is not loaded or in loading, this is not allowed");
                    continue;
                }

                loadedScenes.Remove(sceneName);
                scenesToUnload.Add(sceneName);
            }

            //Finally there is no scene to unload
            if (scenesToUnload.Count < 1)
            {
                onCompleted?.Invoke();
                return;
            }

            var newParameters = new UnloadSceneParameters()
            {
                scenesToUnload = scenesToUnload.ToArray(),
                unloadSceneMode = parameters.unloadSceneMode
            };

            PostCommand(new UnLoadSceneCommand(newParameters, onCompleted));
        }
        
        
        private void Update()
        {
            if (currentCommand == null) return;
            
            currentCommand.Execute();
                
            //Check completion
            if (!currentCommand.IsCompleted) return;
    
            currentCommand = null;

            //Auto execute next command
            if (commandQueue.Count > 0)
            {
                currentCommand = commandQueue.Dequeue();
            }
        }

        private void OnDestroy()
        {
            SceneManager.sceneLoaded -= OnSceneLoaded;
            SceneManager.sceneUnloaded -= OnSceneUnloaded;
        }

        
        #region Callbacks

        private void OnSceneLoaded(Scene scene, LoadSceneMode loadSceneMode)
        {
            if (activeScenes.ContainsKey(scene.name))
            {
                throw new Exception(
                    $"The scene {scene.name} is already loaded, but manager receive an load event from this scene, are you sure you are using this manager to load scene?");
            }

            if (!loadedScenes.Contains(scene.name))
            {
                loadedScenes.Add(scene.name);
                Debug.LogWarning($"The scene {scene.name} has been loaded outside of the manager logic, please use manager to load scene");
            }
            
            activeScenes.Add(scene.name, scene);
        }
        private void OnSceneUnloaded(Scene scene)
        {
            if (!activeScenes.ContainsKey(scene.name))
            {
                throw new Exception(
                    $"The scene {scene.name} is not loaded, but manager receive an unload event from this scene, are you sure you are using this manager to unload scene?");
            }
            
            if (loadedScenes.Contains(scene.name))
            {
                loadedScenes.Remove(scene.name);
                Debug.LogWarning($"The scene {scene.name} has been unloaded outside of the manager logic, please use manager to load scene");
            }
            
            activeScenes.Remove(scene.name);
        }
        
        #endregion

        
        #region Commands

        private void PostCommand(SceneCommand command)
        {
            if (currentCommand == null)
            {
                currentCommand = command;
                return;
            }
            
            commandQueue.Enqueue(command);
        }

        private SceneCommand currentCommand;
        
        private Queue<SceneCommand> commandQueue;

        #endregion

        
        
        [Serializable]
        public struct LoadSceneParameters
        {
            public string[] scenesToLoad;
            public LoadSceneMode loadSceneMode;
            public bool allowSceneActivation;

            public bool HaveOnlyOneSceneToLoad => scenesToLoad.Length < 2;

            public void Execute() => Instance.LoadScene(this, null);
     
            public void Execute(Action onCompleted) =>  Instance.LoadScene(this, onCompleted);
        }

        [Serializable]
        public struct UnloadSceneParameters
        {
            public string[] scenesToUnload;
            public UnloadSceneOptions unloadSceneMode;

            public bool HaveOnlyOneSceneToLoad => scenesToUnload.Length < 2;

            public void Execute() => Instance.UnloadScene(this, null);

            public void Execute(Action onCompleted) => Instance.UnloadScene(this, onCompleted);
        }

        private abstract class SceneCommand
        {
            public abstract bool IsCompleted { get; protected set; }
            
            public abstract void Execute();
        }
        
        private class LoadSceneCommand : SceneCommand
        {
            private readonly LoadSceneParameters parameters;
            private readonly Action onCompleted;
            private readonly List<string> loadedScenes;
            private readonly List<AsyncOperation> asyncOperations;
            
            private bool hasStarted;
            private bool asyncHasStarted;
            private bool waitingForScenesToBeLoaded;
            public sealed override bool IsCompleted { get; protected set; }
            
            public LoadSceneCommand(LoadSceneParameters parameters, Action onCompleted)
            {
                loadedScenes = new List<string>();
                asyncOperations = new List<AsyncOperation>();
                
                this.parameters = parameters;
                this.onCompleted = onCompleted;
                
                IsCompleted = false;
                hasStarted = false;
                asyncHasStarted = false;
                waitingForScenesToBeLoaded = false;
            }

            public override void Execute()
            {
                if (IsCompleted) return;
                
                if (!hasStarted)
                {
                    hasStarted = true;
                    Start();
                }
                
                Update();
            }

            private void Start() => SceneManager.sceneLoaded += OnSceneLoaded;

            private void Update()
            {
                //WAIT FOR ALL SCENE TO BE LOADED
                if (waitingForScenesToBeLoaded)
                {
                    if (loadedScenes.Count >= parameters.scenesToLoad.Length) Complete();
                    return;
                }

                //WAIT FOR ALL ASYNC OPERATIONS
                if (asyncHasStarted)
                {
                    waitingForScenesToBeLoaded = asyncOperations.TrueForAll(x => x.progress >= 0.9f);

                    if (!waitingForScenesToBeLoaded) return; 
                    
                    if (parameters.allowSceneActivation)
                    {
                        foreach (var async in asyncOperations)
                        {
                            async.allowSceneActivation = true;
                        }
                    }
                    else Complete();

                    return;
                }

                //FIRE ALL LOADING
                foreach (var sceneToLoad in parameters.scenesToLoad)
                {
                    var asyncOperation = SceneManager.LoadSceneAsync(sceneToLoad, parameters.loadSceneMode);
                    asyncOperation.allowSceneActivation = false; //We will trigger scene if need only when all scene are loaded
                    asyncOperations.Add(asyncOperation);
                }

                asyncHasStarted = true;
            }

            private void Complete()
            {
                SceneManager.sceneLoaded -= OnSceneLoaded;
                onCompleted?.Invoke();
                IsCompleted = true;
            }

            public void Cancel()
            {
                throw new NotImplementedException("Cancel scenes loading isn't implemented yet");
                
                //TRY CANCEL AFTER ALL ASYNC ARE COMPLETED
                if (waitingForScenesToBeLoaded)
                {
                    //...
                    return;
                }
                
                //TRY CANCEL BEFORE ALL ASYNC ARE COMPLETED
                if (asyncHasStarted)
                {
                    //...
                    return;
                }
                
                //TRY CANCEL BEFORE ALL A SYNC HAVE STARTED
                //...
            }
            
            /// <summary>
            /// Check for all scene loading callback before complete command
            /// </summary>
            /// <param name="scene"></param>
            /// <param name="sceneMode"></param>
            private void OnSceneLoaded(Scene scene, LoadSceneMode sceneMode)
            {
                if (parameters.scenesToLoad.Any(sceneToLoadName => string.Equals(sceneToLoadName, scene.name)))
                {
                    loadedScenes.Add(scene.name);
                }
            }
        }
        
         private class UnLoadSceneCommand : SceneCommand
        {
            private readonly UnloadSceneParameters parameters;
            private readonly Action onCompleted;
            private readonly List<string> unloadedScenes;
            
            private bool hasStarted;
            private bool waitingForScenesToBeUnloaded;
            public sealed override bool IsCompleted { get; protected set; }
            
            public UnLoadSceneCommand(UnloadSceneParameters parameters, Action onCompleted)
            {
                unloadedScenes = new List<string>();
                
                this.parameters = parameters;
                this.onCompleted = onCompleted;
                
                IsCompleted = false;
                hasStarted = false;
                waitingForScenesToBeUnloaded = false;
            }

            public override void Execute()
            {
                if (IsCompleted) return;
                
                if (!hasStarted)
                {
                    hasStarted = true;
                    Start();
                }
                
                Update();
            }

            private void Start() => SceneManager.sceneUnloaded += OnSceneUnload;
 
            private void Update()
            {
                //WAIT FOR ALL SCENE TO BE LOADED
                if (waitingForScenesToBeUnloaded)
                {
                    if (unloadedScenes.Count >= parameters.scenesToUnload.Length) Complete();
                    return;
                }
                
                //FIRE ALL LOADING
                foreach (var sceneToLoad in parameters.scenesToUnload)
                {
                    SceneManager.UnloadSceneAsync(sceneToLoad, parameters.unloadSceneMode);
                }

                waitingForScenesToBeUnloaded = true;
            }

            private void Complete()
            {
                SceneManager.sceneUnloaded -= OnSceneUnload;
                IsCompleted = true;
                onCompleted?.Invoke();
            }

            public void Cancel()
            {
                throw new NotImplementedException("Cancel scenes loading isn't implemented yet");
            }
            
            private void OnSceneUnload(Scene scene)
            {
                if (parameters.scenesToUnload.Any(sceneToUnloadName => string.Equals(sceneToUnloadName, scene.name)))
                {
                    unloadedScenes.Add(scene.name);
                }
            }
        }
    }
}
